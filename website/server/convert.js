/**
 * Copyright 2004-present Facebook. All Rights Reserved.
 *
 */

/* eslint-disable sort-keys */

const fs = require('fs');
const os = require('os');
const path = require('path');
const glob = require('glob');
const mkdirp = require('mkdirp');
const toSlug = require('../core/toSlug');
const languages = require('../languages.js');
const feed = require('./feed');

function splitHeader(content) {
  const lines = content.split(os.EOL);
  let i = 1;
  for (; i < lines.length - 1; ++i) {
    if (lines[i] === '---') {
      break;
    }
  }
  return {
    header: lines.slice(1, i + 1).join('\n'),
    content: lines.slice(i + 1).join('\n'),
  };
}

function backtickify(str) {
  let escaped = '`' + str.replace(/\\/g, '\\\\').replace(/`/g, '\\`') + '`';
  // Replace require( with require\( so node-haste doesn't replace example
  // require calls in the docs
  escaped = escaped.replace(/require\(/g, 'require\\(');

  // Replace ${var} with \${var} so we can use place holders
  return escaped.replace(/\$\{([\w\s\d\'\:\.\(\)\?]*)\}/g, '\\${$1}');
}

// Extract markdown metadata header
function extractMetadata(content) {
  const metadata = {};
  const both = splitHeader(content);
  const lines = both.header.split('\n');
  for (let i = 0; i < lines.length - 1; ++i) {
    const keyvalue = lines[i].split(':');
    const key = keyvalue[0].trim();
    let value = keyvalue.slice(1).join(':').trim();
    // Handle the case where you have "Community #10"
    try {
      value = JSON.parse(value);
    } catch (e) {}
    metadata[key] = value;
  }
  return {metadata, rawContent: both.content};
}

const TABLE_OF_CONTENTS_TOKEN = '<AUTOGENERATED_TABLE_OF_CONTENTS>';

const insertTableOfContents = rawContent => {
  const regexp = /\n###\s+(`.*`.*)\n/g;
  let match;
  const headers = [];
  while ((match = regexp.exec(rawContent))) {
    headers.push(match[1]);
  }

  const tableOfContents = headers
    .map(header => `  - [${header}](#${toSlug(header)})`)
    .join('\n');

  return rawContent.replace(TABLE_OF_CONTENTS_TOKEN, tableOfContents);
};

function buildFile(layout, metadata, rawContent, language) {
  if (typeof language == 'undefined') {
    language = 'en';
  }

  if (rawContent && rawContent.indexOf(TABLE_OF_CONTENTS_TOKEN) !== -1) {
    rawContent = insertTableOfContents(rawContent);
  }

  return [
    '/**',
    ' * @generated',
    ' */',
    'var React = require("React");',
    'var Layout = require("' + layout + '");',
    rawContent && 'var content = ' + backtickify(rawContent) + ';',
    'var Post = React.createClass({',
    rawContent && '  statics: { content: content },',
    '  render: function() {',
    '    return (',
    '      <Layout metadata={' +
      JSON.stringify(metadata) +
      '} language="' +
      language +
      '">',
    rawContent && '        {content}',
    '      </Layout>',
    '    );',
    '  }',
    '});',
    'module.exports = Post;',
  ]
    .filter(e => e)
    .join('\n');
}

function writeFileAndCreateFolder(file, content) {
  mkdirp.sync(file.replace(new RegExp('/[^/]*$'), ''));
  fs.writeFileSync(file, content);
}

function execute() {
  const DOCS_MD_DIR = '../docs/';
  const BLOG_MD_DIR = '../blog/';

  // Extracts the Getting started content from GettingStarted.md
  // and inserts into repo's README
  const gettingStarted = splitHeader(
    fs.readFileSync(DOCS_MD_DIR + 'en/GettingStarted.md', 'utf8')
  ).content.replace(/\(\/jest\//g, '(https://facebook.github.io/jest/');

  let readme = fs.readFileSync('../README.md', 'utf8');
  const guideStart = '<!-- generated_getting_started_start -->';
  const guideEnd = '<!-- generated_getting_started_end -->';
  readme =
    readme.slice(0, readme.indexOf(guideStart) + guideStart.length) +
    gettingStarted +
    readme.slice(readme.indexOf(guideEnd));
  fs.writeFileSync('../README.md', readme);

  const regexSubFolder = /..\/docs\/(.*)\/.*/;

  const enabledLanguages = [];
  languages.filter(lang => lang.enabled).map(lang => {
    enabledLanguages.push(lang.tag);
  });

  // for docs
  glob(DOCS_MD_DIR + '**', (er, files) => {
    const metadatas = {
      files: [],
    };

    files.forEach(file => {
      // extract language
      let language = 'en';
      const match = regexSubFolder.exec(file);
      if (match) {
        language = match[1];
      }

      if (enabledLanguages.indexOf(language) === -1) {
        return; // this language is not enabled, don't process file
      }

      const extension = path.extname(file);
      if (extension === '.md' || extension === '.markdown') {
        const res = extractMetadata(fs.readFileSync(file, 'utf8'));
        const metadata = res.metadata;
        const rawContent = res.rawContent;
        metadata.source = path.basename(file);

        // in permalink replace /en/ language with localized folder
        metadata.permalink = metadata.permalink.replace(
          /\/en\//g,
          '/' + language + '/'
        );
        // change ids previous, next
        metadata.localized_id = metadata.id;
        metadata.id = language + '-' + metadata.id;
        if (metadata.previous) {
          metadata.previous_id = metadata.previous;
          metadata.previous = language + '-' + metadata.previous;
        }
        if (metadata.next) {
          metadata.next_id = metadata.next;
          metadata.next = language + '-' + metadata.next;
        }
        metadata.language = language;
        metadatas.files.push(metadata);

        if (metadata.permalink.match(/^https?:/)) {
          return;
        }

        // Create a dummy .js version that just calls the associated layout
        const layout =
          metadata.layout[0].toUpperCase() +
          metadata.layout.substr(1) +
          'Layout';

        writeFileAndCreateFolder(
          'src/jest/' + metadata.permalink.replace(/\.html$/, '.js'),
          buildFile(layout, metadata, rawContent, language)
        );
      }

      if (extension === '.json') {
        const content = fs.readFileSync(file, 'utf8');
        metadatas[path.basename(file, '.json')] = JSON.parse(content);
      }
    });

    fs.writeFileSync(
      'core/metadata.js',
      '/**\n' +
        ' * @generated\n' +
        ' * @providesModule Metadata\n' +
        ' */\n' +
        'module.exports = ' +
        JSON.stringify(metadatas, null, 2) +
        ';'
    );
  });

  // For the blog
  glob(BLOG_MD_DIR + '**/*.*', (er, files) => {
    const metadatas = {
      files: [],
    };

    files.sort().reverse().forEach(file => {
      // Transform
      //   2015-08-13-blog-post-name-0.5.md
      // into
      //   2015/08/13/blog-post-name-0-5.html
      const filePath = path
        .basename(file)
        .replace('-', '/')
        .replace('-', '/')
        .replace('-', '/')
        // react-middleware is broken with files that contains multiple .
        // like react-0.14.js
        .replace(/\./g, '-')
        .replace(/\-md$/, '.html');

      const res = extractMetadata(fs.readFileSync(file, {encoding: 'utf8'}));
      const rawContent = res.rawContent;
      const metadata = Object.assign(
        {path: filePath, content: rawContent},
        res.metadata
      );

      metadata.id = metadata.title;
      metadatas.files.push(metadata);

      writeFileAndCreateFolder(
        'src/jest/blog/' + filePath.replace(/\.html$/, '.js'),
        buildFile('BlogPostLayout', metadata, rawContent)
      );
    });

    const perPage = 10;
    for (
      let page = 0;
      page < Math.ceil(metadatas.files.length / perPage);
      ++page
    ) {
      writeFileAndCreateFolder(
        'src/jest/blog' + (page > 0 ? '/page' + (page + 1) : '') + '/index.js',
        buildFile('BlogPageLayout', {page, perPage})
      );
    }

    fs.writeFileSync(
      'core/metadata-blog.js',
      '/**\n' +
        ' * @generated\n' +
        ' * @providesModule MetadataBlog\n' +
        ' */\n' +
        'module.exports = ' +
        JSON.stringify(metadatas, null, 2) +
        ';'
    );
  });

  writeFileAndCreateFolder('src/jest/blog/feed.xml', feed('rss'));
  writeFileAndCreateFolder('src/jest/blog/atom.xml', feed('atom'));
}

module.exports = execute;
